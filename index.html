<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image to PDF Converter</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useRef } = React;

    const translations = {
      en: {
        title: "Image to PDF Converter",
        dragDrop: "Drag and drop images here or",
        selectImages: "Select Images",
        convert: "Convert to PDF",
        errorEmpty: "Please upload at least one image.",
        errorInvalid: "Some files were rejected. Only JPEG, PNG, and GIF are supported.",
        remove: "Remove",
        namePrompt: "Enter the name for your PDF file (without .pdf extension):",
        namePlaceholder: "MyDocument"
      },
      uz: {
        title: "Rasmni PDFga aylantirish",
        dragDrop: "Rasmlarni bu yerga tashlang yoki",
        selectImages: "Rasmlarni tanlash",
        convert: "PDFga aylantirish",
        errorEmpty: "Iltimos, kamida bitta rasm yuklang.",
        errorInvalid: "Ba'zi fayllar rad etildi. Faqat JPEG, PNG va GIF qo'llab-quvvatlanadi.",
        remove: "O'chirish",
        namePrompt: "PDF faylingiz uchun nom kiriting (.pdf kengaytmasiz):",
        namePlaceholder: "MeningHujjatim"
      },
      ru: {
        title: "Конвертер изображений в PDF",
        dragDrop: "Перетащите изображения сюда или",
        selectImages: "Выбрать изображения",
        convert: "Конвертировать в PDF",
        errorEmpty: "Пожалуйста, загрузите хотя бы одно изображение.",
        errorInvalid: "Некоторые файлы были отклонены. Поддерживаются только JPEG, PNG и GIF.",
        remove: "Удалить",
        namePrompt: "Введите имя для вашего PDF-файла (без расширения .pdf):",
        namePlaceholder: "МойДокумент"
      }
    };

    const App = () => {
      const [images, setImages] = useState([]);
      const [error, setError] = useState('');
      const [language, setLanguage] = useState('uz');
      const fileInputRef = useRef(null);
      const dropZoneRef = useRef(null);
      const dragItemRef = useRef(null);
      const dragOverItemRef = useRef(null);

      const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
      const t = translations[language];

      const handleFiles = (files) => {
        const validFiles = Array.from(files).filter(file => allowedTypes.includes(file.type));
        if (validFiles.length !== files.length) {
          setError(t.errorInvalid);
        }
        if (validFiles.length === 0) return;

        const newImages = validFiles.map(file => ({
          id: Math.random().toString(36).substr(2, 9),
          file,
          url: URL.createObjectURL(file)
        }));
        setImages(prev => [...prev, ...newImages]);
        setError('');
      };

      const handleDrop = (e) => {
        e.preventDefault();
        dropZoneRef.current.classList.remove('border-blue-500');
        handleFiles(e.dataTransfer.files);
      };

      const handleDragOver = (e) => {
        e.preventDefault();
        dropZoneRef.current.classList.add('border-blue-500');
      };

      const handleDragLeave = () => {
        dropZoneRef.current.classList.remove('border-blue-500');
      };

      const handleFileInput = (e) => {
        handleFiles(e.target.files);
      };

      const removeImage = (id) => {
        setImages(prev => prev.filter(img => img.id !== id));
      };

      const handleDragStart = (index) => {
        dragItemRef.current = index;
      };

      const handleDragEnter = (index) => {
        dragOverItemRef.current = index;
      };

      const handleDragEnd = () => {
        if (dragItemRef.current === null || dragOverItemRef.current === null) return;
        const updatedImages = [...images];
        const [draggedImage] = updatedImages.splice(dragItemRef.current, 1);
        updatedImages.splice(dragOverItemRef.current, 0, draggedImage);
        setImages(updatedImages);
        dragItemRef.current = null;
        dragOverItemRef.current = null;
      };

      const handleTouchStart = (index) => {
        dragItemRef.current = index;
      };

      const handleTouchMove = (e, index) => {
        e.preventDefault();
        const touch = e.touches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        const dropTarget = element?.closest('[data-index]');
        if (dropTarget) {
          dragOverItemRef.current = parseInt(dropTarget.dataset.index, 10);
        }
      };

      const handleTouchEnd = () => {
        if (dragItemRef.current === null || dragOverItemRef.current === null) return;
        const updatedImages = [...images];
        const [draggedImage] = updatedImages.splice(dragItemRef.current, 1);
        updatedImages.splice(dragOverItemRef.current, 0, draggedImage);
        setImages(updatedImages);
        dragItemRef.current = null;
        dragOverItemRef.current = null;
      };

      const generatePDF = async () => {
        if (images.length === 0) {
          setError(t.errorEmpty);
          return;
        }

        const fileName = prompt(t.namePrompt, t.namePlaceholder);
        if (!fileName) {
          setError(t.errorEmpty);
          return;
        }

        const sanitizedFileName = fileName.replace(/[^a-zA-Z0-9-_]/g, '') || 'images';

        const { PDFDocument } = PDFLib;
        const pdfDoc = await PDFDocument.create();

        for (const image of images) {
          const page = pdfDoc.addPage();
          let img;
          if (image.file.type === 'image/jpeg') {
            img = await pdfDoc.embedJpg(await image.file.arrayBuffer());
          } else if (image.file.type === 'image/png') {
            img = await pdfDoc.embedPng(await image.file.arrayBuffer());
          } else {
            continue;
          }

          const { width, height } = img.scale(1);
          const pageWidth = page.getWidth();
          const pageHeight = page.getHeight();
          const scale = Math.min(pageWidth / width, pageHeight / height) * 0.9;
          const scaledWidth = width * scale;
          const scaledHeight = height * scale;

          page.drawImage(img, {
            x: (pageWidth - scaledWidth) / 2,
            y: (pageHeight - scaledHeight) / 2,
            width: scaledWidth,
            height: scaledHeight
          });
        }

        const pdfBytes = await pdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${sanitizedFileName}.pdf`;
        link.click();
        URL.revokeObjectURL(url);
        setError('');
      };

      return (
        <div className="min-h-screen bg-gray-100 flex items-center justify-center p-4 sm:p-6">
          <div className="bg-white rounded-lg shadow-lg p-4 sm:p-6 w-full max-w-4xl">
            <div className="flex justify-between items-center mb-4">
              <h1 className="text-xl sm:text-2xl font-bold">{t.title}</h1>
              <select
                value={language}
                onChange={(e) => setLanguage(e.target.value)}
                className="border rounded px-2 py-1 text-sm"
              >
                <option value="uz">Oʻzbek</option>
                <option value="en">English</option>
                <option value="ru">Русский</option>
              </select>
            </div>

            <div
              ref={dropZoneRef}
              className="border-2 border-dashed border-gray-300 rounded-lg p-4 sm:p-6 mb-4 text-center"
              onDrop={handleDrop}
              onDragOver={handleDragOver}
              onDragLeave={handleDragLeave}
            >
              <p className="text-gray-500 mb-2 text-sm sm:text-base">{t.dragDrop}</p>
              <input
                type="file"
                multiple
                accept="image/jpeg,image/png,image/gif"
                onChange={handleFileInput}
                ref={fileInputRef}
                className="hidden"
              />
              <button
                onClick={() => fileInputRef.current.click()}
                className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 text-sm sm:text-base"
              >
                {t.selectImages}
              </button>
            </div>

            {error && (
              <div className="bg-red-100 text-red-700 p-3 rounded mb-4 text-sm sm:text-base">
                {error}
              </div>
            )}

            {images.length > 0 && (
              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 sm:gap-4 mb-4">
                {images.map((image, index) => (
                  <div
                    key={image.id}
                    data-index={index}
                    className="relative group cursor-move touch-none"
                    draggable
                    onDragStart={() => handleDragStart(index)}
                    onDragEnter={() => handleDragEnter(index)}
                    onDragEnd={handleDragEnd}
                    onTouchStart={() => handleTouchStart(index)}
                    onTouchMove={(e) => handleTouchMove(e, index)}
                    onTouchEnd={handleTouchEnd}
                  >
                    <img
                      src={image.url}
                      alt="Thumbnail"
                      className="w-full h-24 sm:h-32 object-cover rounded"
                    />
                    <div className="absolute inset-0 flex items-center justify-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity bg-black bg-opacity-50 rounded">
                      <button
                        onClick={() => removeImage(image.id)}
                        className="bg-red-500 text-white px-2 py-1 rounded text-xs sm:text-sm"
                      >
                        {t.remove}
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}

            <button
              onClick={generatePDF}
              className="w-full bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600 disabled:bg-gray-400 text-sm sm:text-base"
              disabled={images.length === 0}
            >
              {t.convert}
            </button>
          </div>
        </div>
      );
    };

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>